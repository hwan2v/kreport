input {
  # API 컨테이너가 남기는 파일 로그 tail
  file {
    path => ["/var/log/app/app.log", "/var/log/app/access.log"]
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/data/sincedb_app"   # 재시작 후 이어읽기
    codec => multiline {
      # 타임스탬프로 시작하지 않는 줄은 이전 줄의 연속(스택트레이스 등)
      pattern => "^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2},\d{3} "
      negate => true
      what => "previous"
    }
  }
}

filter {
  # 공통 포맷:
  # 2025-09-17 13:15:22,123 INFO [logger.name] [trace-id] message...
  grok {
    match => {
      "message" => [
        # 일반 로그 (default formatter)
        "^(?<ts>%{TIMESTAMP_ISO8601}) %{LOGLEVEL:level} \[(?<logger>[^\]]+)\] \[(?<trace_id>[^\]]+)\] %{GREEDYDATA:msg}$",
        # 혹시 uvicorn.access 등 변형이 있더라도 위 패턴으로 대부분 매칭됨
        "^(?<ts>%{TIMESTAMP_ISO8601}) %{LOGLEVEL:level} \[(?<logger>[^\]]+)\] \[(?<trace_id>[^\]]*)\] %{GREEDYDATA:msg}$"
      ]
    }
    tag_on_failure => ["_grok_common_fail"]
  }

  # access 로그 추가 파싱 (우리 미들웨어가 남기는 형식):
  # GET /health 200 1.23ms
  if [logger] == "access" or "access" in [logger] {
    grok {
      match => {
        "msg" => "^(?<http_method>[A-Z]+) %{DATA:url_path} %{INT:http_status:int} %{NUMBER:duration_ms:float}ms$"
      }
      tag_on_failure => ["_grok_access_fail"]
    }
  }

  # 날짜 파싱 -> timestamp
  date {
    match => ["ts", "ISO8601"]
    timezone => "Asia/Seoul"
    target => "timestamp"
  }

  # 필드 정리/타입 캐스팅
  mutate {
    rename => { "msg" => "message" }
    remove_field => ["ts", "host", "path", "version"]
  }
}

output {
  # 콘솔 디버깅 (필요시 주석 해제)
  # stdout { codec => rubydebug }

  opensearch {
    hosts => ["http://opensearch:9200"]
    index => "kreport-logs-%{+YYYY.MM.dd}"
    ssl => false
  }
}
